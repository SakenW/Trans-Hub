## **第二部分：Trans-Hub 项目技术宪章**

> **范围**: 本部分是 `Trans-Hub` 项目的**专用技术蓝图和架构约束**。

#### **1. 核心架构原则**

1.1. **单一职责 (SRP)**: 每个模块、类、函数**必须**只做一件事。
1.2. **依赖倒置 (DIP)**: 核心业务逻辑**必须**依赖于**抽象 (`typing.Protocol`)**，而不是具体的实现。
1.3. **单向依赖与包结构**: **必须**遵循严格的**单向依赖**层次结构。高层模块（如 CLI）可以依赖低层模块（如 Coordinator），但低层模块**严禁**导入高层模块。
1.4. **无副作用导入**: **严禁**在模块的顶层（即导入时）执行有副作用的操作（如网络请求、文件 I/O、日志输出）。所有初始化逻辑**必须**由明确的函数调用（如 `Coordinator.initialize`, `cli.main`）触发。
1.5. **服务层抽象**: 核心业务逻辑**必须**被封装在明确的服务层（如 `解析层`、`内容操作层`）中。高层模块（如 `Coordinator`、CLI 命令）**必须**通过这些服务层接口进行交互，**严禁**直接执行复杂的、包含多步业务逻辑的数据查询或操作。
1.6. **配置与实现分离**: 核心配置模块（如 `config.py`）**必须**只负责定义和加载配置的“形状”和原始数据，**严禁**静态导入任何具体的业务实现模块（如引擎模块）。业务实现的配置**必须**通过“自注册”和“动态解析”的方式在运行时加载。
1.7. **可选依赖隔离原则**: 任何实现可选功能（extras）的模块，**严禁**在模块的顶层直接导入其可选依赖库。所有可选依赖的导入**必须**通过以下两种方式之一进行处理，以确保在未安装相应 extra 时，系统仍能正常导入和运行：
    *   在 `if TYPE_CHECKING:` 块中进行类型提示导入，并在实际使用该库的函数或方法内部进行运行时导入。
    *   在模块顶层使用 `try...except ImportError:` 块进行安全导入。

#### **2. 数据、配置与业务规则**

2.1. **数据容器**: **必须**使用 `pydantic` 作为核心数据类库，以确保运行时的数据验证和清晰的 schema 定义。
2.2. **配置加载**: 配置**必须**集中且与环境无关。所有配置项**必须**通过 `TransHubConfig` 进行管理，**严禁**在代码中硬编码任何环境相关的“魔法数字”（如端口号、API端点等）。
2.3. **稳定引用原则**: 系统**必须**区分内部主键（如 UUID）和对外暴露的**稳定业务引用ID**（如 `business_id`）。所有外部系统或 API 调用**必须**使用稳定引用 ID 来定位内容，**严禁**暴露或依赖内部主键。
2.4. **结构化载荷优先**: 对于核心内容（原文、译文），**必须**优先使用结构化的数据格式（如 **JSON**）进行存储（`payload` 字段），即使当前内容只是简单文本。这为未来的功能扩展（如富文本、组件化内容）预留了能力。
2.5. **强制审计日志**: 所有对核心数据模型（`th_content`, `th_translations`, `th_policies` 等）的**写操作**（创建、更新、删除、状态变更），**必须**在同一个数据库事务中，向 `th_audit_logs` 表记录一条详细的、不可变的审计日志。

#### **3. 数据库实践**

3.1. **数据库演进**: 项目**必须**建立一个标准化的数据库迁移流程。在 `v3.0.0` 发布后，任何 Schema 变更**必须**通过创建**新的、独立的、带版本号的迁移脚本**来实现，**严禁**修改已发布的迁移脚本。
3.2. **约束优先**: 在设计 Schema 时，**必须**为所有用于 `ON CONFLICT` 推断的列或列组创建显式的 `PRIMARY KEY` 或 `UNIQUE` 约束。
3.3. **约束命名**: 所有重要的约束（`UNIQUE`, `FOREIGN KEY`, `CHECK`），**建议**使用 `CONSTRAINT constraint_name ...` 的语法进行明确命名，以提高错误信息的可读性和可维护性。
3.4. **日期与时间戳比较**: **必须**明确区分日期（Date）和时间戳（Timestamp）的比较逻辑。对于基于“天”的保留策略（如垃圾回收），SQL 查询**必须**使用日期函数（如 `DATE(...)`）对时间戳字段进行转换，以避免因时间部分导致的错误比较。

#### **4. 测试体系**

4.1. **测试覆盖**: 所有功能与 Bug 修复**必须**有对应的测试。
4.2. **测试分层**: **必须**建立“`tests/unit` + `tests/integration`”的物理分层结构。
    *   **单元测试**: 必须快速、隔离，严禁执行任何网络或文件 I/O。
    *   **集成测试**: 可以执行文件 I/O、数据库操作，验证多个组件的协同工作。
4.3. **测试原则**:
    *   测试应基于**行为（输入输出）**，而非内部实现细节。
    *   单元测试**必须**是**确定性的**，**严禁**依赖物理时间（如 `time.sleep`），应使用 `pytest-mock` 或 `asyncio` 的工具来控制时间。
4.4. **Mocking 规范**:
    *   **必须**为 `async def` 目标使用 `AsyncMock`。
    *   创建时**必须**使用 `spec=True` 或 `autospec=True`，以确保 mock 对象与原始对象的接口一致。
    *   **修正**: 当 `autospec` 与 `new` 参数一起使用并导致 `TypeError` 时，**必须**移除 `autospec=True`。手动提供 `new` 对象时，应由开发者自己保证其接口的兼容性。

#### **5. 依赖、安全与 CI/CD**

5.1. **依赖管理**:
    *   **必须**使用 Poetry 的**依赖组 (Dependency Groups)**（如 `[tool.poetry.group.dev.dependencies]`）来严格分离核心依赖、可选依赖、开发依赖和文档依赖。
    *   **必须**确保 `pyproject.toml` 中的 `python` 版本约束、`classifiers` 以及所有静态分析工具（`ruff`, `mypy`）的目标版本声明**完全一致**。
5.2. **依赖最小化**: 核心库的依赖**必须**保持最小化，新功能应优先通过 `extras` 实现。
5.3. **凭证安全**: **严禁**在代码库中提交任何明文密钥。所有凭证**必须**通过环境变量或安全的密钥管理服务进行管理。
5.4. **CI 门禁**: 所有代码合并前，**必须**通过 CI 流水线中定义的所有检查。

#### **6. 项目特定约定**

6.1. **文件头**: 每个 `.py` 和 `.sql` 文件首行**必须**添加一行标识其完整路径的注释。
6.2. **脚本与示例代码规范**: 对于 `examples/` 或 `tools/` 目录下的脚本，其 `sys.path` 修改逻辑**必须**置于文件顶部，所有 `import` 语句**必须**附带 `# noqa: E402`。